package org.haven.reporting.application.services;

import org.haven.reporting.domain.pithic.HicInventoryData;
import org.haven.reporting.domain.pithic.PitCensusData;
import org.haven.shared.vo.UserId;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Lightweight aggregation facade used while the housing assistance module is absent.
 * It produces empty but structurally valid PIT/HIC payloads so that downstream flows continue to work.
 */
@Service
public class PitHicAggregationService {

    private final Map<UUID, PitCensusData> pitStore = new ConcurrentHashMap<>();
    private final Map<UUID, HicInventoryData> hicStore = new ConcurrentHashMap<>();

    public PitCensusData generatePitCensusData(LocalDate censusDate,
                                               String continuumCode,
                                               String organizationId,
                                               UserId generatedBy) {
        PitCensusData censusData = new PitCensusData(
            UUID.randomUUID(),
            censusDate,
            continuumCode,
            organizationId,
            generatedBy != null ? generatedBy.getValue() : "system"
        );

        censusData.aggregateHouseholdData(new PitCensusData.HouseholdAggregation(0, 0, 0, 0));
        censusData.aggregateDemographicData(new PitCensusData.DemographicAggregation(
            0, 0, 0, 0,
            0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ));
        censusData.aggregateSpecialPopulationData(new PitCensusData.SpecialPopulationAggregation(0, 0, 0, 0, 0, 0));
        censusData.aggregateLocationData(new PitCensusData.LocationAggregation(0, 0, 0, 0));
        censusData.updateDataQualityMetrics(0, 0, 1.0);
        censusData.getMetadata().put("note",
            "Generated by placeholder PIT aggregation while housing-assistance module is unavailable.");

        pitStore.put(censusData.getCensusId(), censusData);
        return censusData;
    }

    public HicInventoryData generateHicInventoryData(LocalDate inventoryDate,
                                                     String continuumCode,
                                                     String organizationId,
                                                     UserId generatedBy) {
        HicInventoryData inventoryData = new HicInventoryData(
            UUID.randomUUID(),
            inventoryDate,
            continuumCode,
            organizationId,
            generatedBy != null ? generatedBy.getValue() : "system"
        );

        inventoryData.aggregateEmergencyShelterData(new HicInventoryData.EmergencyShelterAggregation(
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        ));
        inventoryData.aggregateTransitionalHousingData(new HicInventoryData.TransitionalHousingAggregation(
            0, 0, 0, 0, 0, 0, 0
        ));
        inventoryData.aggregateRapidRehousingData(new HicInventoryData.RapidRehousingAggregation(
            0, 0, 0, 0, 0, 0
        ));
        inventoryData.aggregatePermanentSupportiveData(new HicInventoryData.PermanentSupportiveAggregation(
            0, 0, 0, 0, 0, 0, 0
        ));
        inventoryData.updateUtilizationMetrics(new HicInventoryData.UtilizationMetrics(
            0.0, 0.0, 0.0, 0.0, 0.0
        ));
        inventoryData.updatePitOccupancy(new HicInventoryData.PitOccupancy(0, 0, 0, 0, 0));
        inventoryData.updateDataQualityMetrics(0, 0, 1.0);
        inventoryData.getMetadata().put("note",
            "Generated by placeholder HIC aggregation while housing-assistance module is unavailable.");

        hicStore.put(inventoryData.getInventoryId(), inventoryData);
        return inventoryData;
    }

    public Optional<PitCensusData> findPitCensus(UUID censusId) {
        return Optional.ofNullable(pitStore.get(censusId));
    }

    public Optional<HicInventoryData> findHicInventory(UUID inventoryId) {
        return Optional.ofNullable(hicStore.get(inventoryId));
    }

    public List<PitCensusData> listPitCensusBetween(LocalDate start, LocalDate end) {
        return pitStore.values().stream()
            .filter(data -> !data.getCensusDate().isBefore(start) && !data.getCensusDate().isAfter(end))
            .collect(Collectors.toList());
    }

    public List<HicInventoryData> listHicInventoryBetween(LocalDate start, LocalDate end) {
        return hicStore.values().stream()
            .filter(data -> !data.getInventoryDate().isBefore(start) && !data.getInventoryDate().isAfter(end))
            .collect(Collectors.toList());
    }

    public Map<UUID, PitCensusData> getPitStoreSnapshot() {
        return Map.copyOf(pitStore);
    }

    public Map<UUID, HicInventoryData> getHicStoreSnapshot() {
        return Map.copyOf(hicStore);
    }
}
